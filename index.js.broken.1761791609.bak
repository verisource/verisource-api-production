#!/usr/bin/env node
/**
 * Minimal HTTP API for media verification (image + video).
 * POST /verify
 * Body (multipart/form-data) with:
 *  - file: uploaded image or video (field name: "file")
 */

"use strict";

/* eslint-disable no-console */

const express = require("express");
const multer = require("multer");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const { spawnSync } = require("child_process");
# shows what file `npm start` would run (if defined)
cat package.json | jq -r '.main, .scripts.start'

# find the verify route to locate the server file
grep -Rn 'app.post("/verify"' .

# common server filenames
ls -1 index.js server.js app.js src/ dist/
index.js
node index.js
./server-enhanced.ts:338:app.post("/verify", upload.single("file"), async (req: Request, res: Response) => {
./index.js.backup:80:app.post("/verify", upload.single("file"), async (req, res) => {
./server-production.ts:432:app.post("/verify", upload.single("file"), async (req: Request, res: Response) => {
./index.js:89:app.post("/verify", upload.single("file"), async (req, res) => {
./server-ultimate.ts:684:app.post("/verify", upload.single("file"), async (req: Request, res: Response) => {
ls: cannot access 'server.js': No such file or directory
ls: cannot access 'app.js': No such file or directory
ls: cannot access 'src/': No such file or directory
ls: cannot access 'dist/': No such file or directory
index.js

// Optional: project's canonicalization (if available)
let fingerprintImage;
try {
  ({ fingerprintImage } = require("./canonicalization.js"));
} catch {
  // no-op; we'll use a fallback
}

const app = express();
app.use(express.json({ limit: "5mb" }));

// Stable temp dir for uploads
const upload = multer({ dest: "/tmp/verisource_uploads" });

/** ---------------------------- Utilities ---------------------------- **/

/** Fallback: simple SHA-256 over raw bytes + basic metadata */
function fallbackFingerprintImage(buffer, absPath, mimeType) {
  const hash = crypto.createHash("sha256").update(buffer).digest("hex");
  const ext = path.extname(absPath).toLowerCase();
  const mime =
    mimeType ||
    (ext === ".png" ? "image/png" :
     ext === ".jpg" || ext === ".jpeg" ? "image/jpeg" :
     ext === ".webp" ? "image/webp" :
     ext === ".gif" ? "image/gif" :
     "application/octet-stream");

  return {
    kind: "image",
    path: absPath,
    filename: path.basename(absPath),
    size_bytes: buffer.length,
    sha256_hex: hash,
    mime_type: mime,
  };
}

/** Call the video worker and parse JSON */
function runVideoWorker(inputPath) {
  const run = spawnSync("node", ["worker/video-worker.js", inputPath], {
    encoding: "utf8",
    maxBuffer: 50 * 1024 * 1024, // 50MB
  });
  if (run.status !== 0) {
    const errTxt = (run.stderr || run.stdout || "").trim();
    throw new Error(errTxt || "video-worker failed");
  }
  return JSON.parse(run.stdout);
}

async function processVideoCanonical(absPath /*, opts */) {
  return runVideoWorker(absPath);
}

/** ---------------------------- Routes ---------------------------- **/

app.get("/health", (req, res) => {
  res.json({ status: "ok", service: "verisource-media-verifier" });
});

/**
 * POST /verify
 * Accepts a single file upload (image or video).
 * - Images: canonicalization.js:fingerprintImage (if present) or fallback
 * - Videos: processed via worker/video-worker.js (JSON out)
 *
 * Req: multipart/form-data with field name "file"
 */
app.post("/verify", upload.single("file"), async (req, res) => {
  let absPath;
  try {
    if (!req.file) {
      return res.status(400).json({ error: "No file uploaded. Use field name 'file'." });
    }

    absPath = path.resolve(req.file.path);
    const originalName = req.file.originalname || path.basename(absPath);
    const contentType = req.file.mimetype || "application/octet-stream";
    const size = fs.statSync(absPath).size;

    const isImage =
      /^image\//i.test(contentType) ||
      /\.(png|jpe?g|webp|gif|tiff?|bmp)$/i.test(originalName);

    const isVideo =
      /^video\//i.test(contentType) ||
      /\.(mp4|mov|m4v|webm|mkv|avi)$/i.test(originalName);

    let payload;

    if (isImage) {
      const data = fs.readFileSync(absPath);

      // width/height/format
      const { width, height, type } = require("image-size")(absPath);

      // Canonicalization (project pipeline or fallback)
      let canonical;
      if (typeof fingerprintImage === "function") {
        canonical = await fingerprintImage(data, {
          path: absPath,
          filename: originalName,
          mimeType: contentType,
        });
      } else {
        canonical = fallbackFingerprintImage(data, absPath, contentType);
      }

      payload = {
        kind: "image",
        filename: originalName,
        mime_type: contentType,
        size_bytes: data.length,
        width,
        height,
        format: type,
        canonical,
      };

    } else if (isVideo) {
      const canonical = await processVideoCanonical(absPath, {});
      payload = {
        kind: "video",
        filename: originalName,
        mime_type: contentType,
        size_bytes: size,
        canonical,
      };

    } else {
      return res.status(415).json({
        error: `Unsupported content type: ${contentType}`,
        hint: "Accepts common image/* (png,jpg,webp,...) and video/* (mp4,mov,webm,...)",
      });
    }

    return res.status(200).json(payload);
  } catch (err) {
    console.error(err && err.stack ? err.stack : String(err));
    return res.status(500).json({ error: "Verification failed", detail: String(err) });
  } finally {
    // best-effort cleanup
    try { if (absPath) fs.unlinkSync(absPath); } catch {}
  }
});

/** ---------------------------- Boot ---------------------------- **/

const PORT = process.env.PORT || 8080;
app.listen(PORT, () => {
  console.log(`Verifier API listening on :${PORT}`);
  console.log(`Health check: http://localhost:${PORT}/health`);
  console.log(`Verify endpoint: POST http://localhost:${PORT}/verify (field: file)`);
});
